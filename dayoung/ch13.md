# ch13. 쓰레드(Thread)
## 13.1 프로세스와 스레드
* 프로세스 = 실행중인 프로그램
* 스레드 = 프로세스 자원을 이용해서 실제 작업 수행아는 애
  * 제한은 없지만 프로세스 메모리 한계에 따라 스레드 수가 결정됨

## 13.2 스레드의 구현과 실행
Thread클래스를 상속받으면 다른 클래스 상속받지 못하기 때문에 Runnable인터페이스 구현하는 방식이 일반적(더 객체지향적!)
* Thread 클래스를 상속
* Runnable 인터페이스를 구현

구현만 했다고 실행되는게 아니라 `start()`를 해야만 스레드가 실행됨

## 13.3 start()와 run()
* `run()` : 클래스에 선언된 메서드를 호출하는 것
* `start()` : 새로운 스레드가 작업을 실행하는데 필요한 호출스택을 생성한 뒤 `run()`을 호출 -> 호출스택에 `run()`이 올라가게 함
* main스레드
  * main메서드 작업을 수행하는것도 스레드! -> main스레드
  * 실행중인 사용자 스레드가 하나도 없을 때 프로그램은 종료됨

## 13.4 싱글스레드와 멀티스레드
context switching 때문에 싱글스레드보다 멀티스레드 시간이 더 걸림
* 싱글코어에 CPU만을 사용하는 계산작업이면 멀티스레드보다 싱글스레드가 효율적

두 스레드가 다른 자원을 사용하는 작업의 경우 싱글스레드 프로세스보다 멀티스레드 프로세스가 효율적

## 13.5 스레드의 우선순위
1~10 범위의 우선순의를 가짐(숫자 높을수록 우선순위 높음)
* 스레드에 우선순위 부여하는 대신 작업에 우선순위를 두는게 나을수도(스레드 우선순위와 관련된 구현이 JVM마다 다를 수 있음)

## 13.6 스레드그룹
* 관련된 스레드를 그룹으로 다루기 위함

## 13.7 데몬스레드
* 일반 스레드의 작업을 돕는 보조적인 역할을 하는 스레드
* 일반스레드 모두 종료되면 데몬스레드는 강제적으로 종료됨(일반스레드 종료되면 도울 스레드가 없어짐 -> 역할사라짐)

## 13.8 스레드의 실행제어
동기화와 스케줄링의 어려움

## Q)
* 싱글코어에서 멀티스레드가 더 효율적인 케이스가 있을까요?