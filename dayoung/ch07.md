# ch07. 객체지향 프로그래밍2
## 7.1 상속(inheritance)
상속의 정의와 장점
* 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 -> 적은양의 코드로 새로운 코드 작성, 코드 유지보수에 용이
* 생성자와 초기화 블럭은 상속되지 않음. 멤버만 상속됨
* 자손클래스 멤버 개수는 조상클래스보다 항상 같거나 많다
* 자손클래스 인스턴스를 생성하면 조상클래스 멤버와 자손클래스 멤버가 합쳐진 하나의 인스턴스로 생성됨


클래스간 관계 - 포함관계
* 상속관계 : ~은 ~이다 (is - a)
* 포함관계 : ~은 ~을 가지고 있다(has - a)
* 위 문장으로 상속관계/포함관계를 이해해서 구분한다


단일 상속(single inheritance)
* 다중상속의 단점 : 클래스간 관계가 복잡해지고, 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 없다....
* 단일상속 때문에 복합적 기능을 작성하기 다소 어렵지만 클래스간 관계가 명확해지고 코드를 더욱 신뢰할 수 있게 만들어준다


Object 클래스 - 모든 클래스의 조상
* 모든 클래스의 상속 계층도 최상위에 있는 조상 클래스... 다른 클래스를 상속받지 않는 모든 클래들은 자동적으로 Obejct 클래스로부터 상속받게 함...
* `toString()` `equals()` 같은 메서드가 정의되어 있음

## 7.2 오버라이딩(overriding)
오버라이딩이란?
* 조상클래스로부터 상속받은 메서드 내용을 변경하는 것.
* 상속받은 내용을 자신에 맞게 변경


오버라이딩의 조건
* 자손클래스에서 오버라이딩하는 메서드는 조상클래스 메서드와
  * 이름이 같고
  * 매개변수가 같고
  * 반환타입이 같아야 함
* 접근제어자와 예외는 제한된 조건 하에서만 다르게 변경 가능...
  * 접근 제어자는 조상클래스의 메서드보다 좁은 범위로 변경 불가능 (조상클래스가 protected면 오버라이딩하는 자손은 protected, public만 가능)
  * 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다
  * 인스턴스메서드를 static 메서드나 그 반대로 변경할 수 없다.
    * static 멤버들은 자신을이 정의된 클래스에 묶여있음. 자식 클래스에서 똑같은 이름의 static 클래스를 만들수는 있지만 오버라이딩은 아님


오버로딩 vs 오버라이딩
* 오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new)
* 오버라이딩(overrriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify)


super
* 자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
* static 메서드는 인스턴스와 관련이 없음 -> super도 static 메서드에는 사용 불가하고 인스턴스 메서드에서만 사용할 수 있음


super() - 조상클래스 생성자
* 조상클래스의 생성자를 호춣라는데 쓰임
* Object 클래스를 제외한 모든 클래스 생성자 첫줄에는 자신의 다른 생성자 또는 조상 생성자를 호출해야 함 -> 그렇지 않으면 컴파일러는 자동으로 생성자 첫줄에 `super();` 을 추가


## 7.3 package와 import
패키지(package)
* 클래스의 묶음.
* 이름이 같은 클래스더라도 서로 다른 패키지에 속하면 패키지명으로 구분 가능
* 하나의 소스파일에는 첫번째 문장으로 단 한번의 패키지 선언만을 허용
* 모든 클래스는 반드시 하나의 패키지에 속해야 함
* 패키지는 점(.)을 구분자로 해서 계층구조를 구성할 수 있음
* 패키지는 물리적으로 클래스파일(.class)을 포함하는 하나의 디랙토리


import문
* 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공


static import문
* static 멤버를 호출할 때 클래스 이름을 생략 가능. static 멤버를 임포트할 때 사용하는 것..

## 7.4 제어자(modifier)
제어자란?
* 클래스, 변수, 메서드 선언부에 함께 사용되어 부가적 의미 제공
* 접근제어자
  * `public` `protected` `default` `private`
* 그 외
  * `static` `final` `abstract` `native` `transient` `synchronized` `volatile` `strictfp`


static - 클래스의, 공통적인
* 인스턴스와 관계없는 값을 가짐.
* static이 사용될 수 있는 곳 - 멤버 변수, 메서드, 초기화 블럭


final - 마지막의, 변경될 수 없는
* 값을 변경할 수 없는 상수가 되고, 메서드에 사용하면 오버라이딩 할 수 없고, 클래스에 사용하면 자손 클래스 정의 못하게 됨
* final이 사용될 수 있는 곳 - 클래스, 멤버 변수, 메서드, 지역변수,
* 상수이기 때문에 일반적으로 선언과 초기와 동시에 하지만, 인스턴스 변수면 생성자에서 초기화 가능


abstract - 추상의, 미완성의
* 선언부만 작성하고 실제 수행 내용은 구형하지 않은 추상메서드/클래스를 구현하는데 사용
* abstract가 사용될 수 있는 곳 - 클래스, 메서드


접근 제어자(access modifier)
* private : 같은 클래스 내에서만 접근 가능
* default : 같은 패키지 내에서만 접근 가능
* protected : 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근 가능
* public : 접근 제한 없음
* 접근제어자를 사용하는 이유
  * 외부로부터 데이터 보호
  * 외부에서는 불필요한, 내부적으로만 사용하는 부분 감추기 위함


제어자(modifier)의 조합
* 메서드에 static과 abstract를 함께 사용할 수 없다
* 클래스에 abstract와 final을 동시에 사용할 수 없다
* abstract 메서드의 접근제어자가 private일 수 없다
* 메서드에 private과 final을 같이 사용할 필요는 없다 -> 접근제어자가 private 메서드는 오버라이딩 될 수 없기 때문에 둘 중 하나만 사용해도 의미가 충분...

## 7.5 다형성(polymorphism)
다형성이란?
* 여러 형태를 가질 수 있는 능력...
* 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함
* 반대로 자손타입의 참조변수로 조상타입 인스턴스를 참조할 수는 없음...


참조변수 형변환
* 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입 참조변수를 자손타입 참조변수로 형변환 가능
  * 자손 -> 조상 : 형변환 생략 가능
  * 자손 <- 조상 : 형변환 생략 불가
* 자손간 형변화는 불가. 직접 상속받은 클래스간만 형변환 가능
* 형변환은 참조변수 타입을 변경하는거지 인스턴스를 변환하는게 아님. 참조변수 형변환은 인스턴스에 아무런 영향 X


instanceof 연산자
* 참조변수가 참조하고 있는 실제 인스턴스 타입을 확인
* 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하는 것


참조변수와 인스턴스의 연결
* 조상타입의 참조변수로 자손 인스턴스 참조하는 경우와 자손 참소변수로 자손 인스턴스 참조하는 경우  다른 결과를 얻음...
* 메서드의 경우 오버라이딩 된 메서드가 호출
* 멤버변수를 참조변수 타입에 따라 달라짐


## 7.6 추상 클래스(abstract class)
추상클래스란?
* 미완성 설계도
* 추상메서드를 포함하지 않은 클래스에도 abstract를 붙여 추상클래스로 만들 수 있음 -> 추상클래스로 지정되면 클래스 인스턴스 생성 불가


추상 메서드
* 선언부만 작성하고 구현부는 작성하지 않고 남겨둔것.


## 7.7 인터페이스(interface)
인터페이스란?
* 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높다.
* 추상메서드와 상수만을 멤버로 가질 수 있고 그 외의 어떤 요소도 허용 X
* 추상클래스가 미완성 설계도라면 인터페이스는 기본설계도.


인터페이스의 작성
* 모든 멤버변수는 public static final -> 생략 가능
* 모든 메서드는 public abstract -> 생략 가능


인터페이스의 상속
* 다중상속 가능
* static 상수만 정의 가능하기 때문에 조상클래스 멤버변수와 충돌하는 경우는 거의 없고, 충돌되어도 클래스명을 붙여 구분 가능


인터페이스의 다형성
* 리턴타입이 인터페이스라는것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것.


인터페이스의 장점
* 개발시간 단축 가능
* 표준화 가능
* 서로 관계없는 클래스들에 관계를 맺어줄 수 있음
* 독립적인 프로그래밍 가능


인터페이스의 이해
* 클래스를 사용하는쪽과 클래스를 제공하는 쪽이 있음
* 메서드를 사용하는쪽에서는 사용하는 메서드의 선언부를 알면 됨(내용은 몰라도 됨)


디폴트 메서드와 static 메서드
* 1.8부터 디폴트, static 선언 가능...
* 디폴트 메서드 -> 기존 메서드와 이름 중복되어 충돌하는 경우
  * 여러 인터페이스의 디폴트 메서드간 충돌 : 인터페이스 구현 클래스에서 디폴트 클래스 오버라이딩 해야 함
  * 디폴트메서드와 조상클래스 메서드간 충돌 : 조상클래스 메서드가 상속되고 디폴트메서드는 무시됨

## 7.8 내부 클래스(inner class)
내부클래스란?
* 내부에 선언된 클래스.

내부클래스 장점
* 내부 클래스에서 외부 클래스 멤버를 쉽게 접근 가능
* 코드 복잡성을 줄일 수 있음(캡슐화)(

## Q)
* 오버라이딩 시 조상클래스의 메서드보다 좁은 범위로 변경하지 못하는 이유가 무엇일까요?
* 어떤 상황에서 추상클래스를 사용하고, 어떤 상황에서 인터페이스를 사용할까요?]
* 인터페이스의 멤버변수가 public static final인 이유가 무엇일까요?