# 자바의 정석

# ch4-조건문과 반복문
> Q. switch 와 if 반복문 성능 차이에 대해서 설명해주세요. 그리고 어떤 기준으로 조건문을 선택해야할까요?

# ch5-배열
## 배열 복사하는 법
1. 기존 배열의 2배 정도 길이의 배열을 생성한다.
    - for문으로 기존 배열의 값을 하나 씩 접근해서 길이 2배 배열에 값을 저장한다.
    - 기존 배열의 참조 변수가 가리키는 값을 길이 2배 배열의 참조 변수 값으로 바꾼다.
- 2. System.Arraycopy() 이용
    - 요소 하나 하나 씩 접근해서 복사하는 게 아니라 지정된 범위의 값을 한번에 통째로 복사한다.
        - Q. 어떻게 가능할까?
            - 각 요소들이 연속적으로 저장되어 있다는 배열의 특성 때문에 가능하다.

> Q. 배열을 복사하는 방법에는 어떤 게 있나요? 그리고 효율적인 방법이 무엇이고 그 이유는?

# ch06-객체지향 프로그래밍1
## 클래스
- 객체를 생성하기 위한 툴
- 데이터와 함수의 결합
    - 참고
        - 변수: 하나의 데이터를 저장할 수 있는 공간
        - 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
        - 구조체: 관련된 여러 데이터를 종류에 관계 없이 하나의 집합으로 저장할 수 있는 공간
- 사용자 정의 타입
## 선언 위치에 따른 변수의 종류
- 클래스 변수(static 변수, 공유 변수)
    - 선언 위치: 클래스 영역
    - 생성 시기: 클래스가 메모리에 올라갈 때
    - 모든 인스턴스가 공통된 저장 공간(변수)을 공유한다.
    - 객체 생성 없이 `클래스이름.클래스변수`로 직접 사용 가능
- 인스턴스 변수
    - 선언 위치: 클래스 영역
    - 생성 시기: 인스턴스가 생성되었을 때
    - 인스턴스마다 서로 다른 값을 가짐
- 지역 변수
    - 선언 위치: 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블록 내부)
    - 생성 시기: 변수 선언문이 수행되었을 때
    - 메서드 내에서만 사용 가능
## 메서드
- 매개 변수의 유효성 검사 코드 필수
## JVM 메모리 구조
- 메서드 영역
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 .class 파일을 읽어서 클래스에 대한 정보를 메서드 영역에 저장한다.
- 힙
    - 인스턴스가 생성되는 공간
- 호출 스택(call stack or execution stack)
    - 메서드 작업에 필요한 메모리 공간 제공
    - 메서드가 작업을 마치면 메모리 공간은 반환되어 비워진다.
## 기본형 매개변수와 참조형 매개변수
- 기본형 매개변수
    - 변수의 값을 읽기만 할 수 있음
- 참조형 매개변수
    - 변수의 값을 읽고 변경할 수 있음
        - 어떻게? 값이 아니라 값이 저장된 주소가 매개변수로 전달됨.
            - 서로 다른 메서드 내에서 주소값을 갖고 있는 변수를 참조한다.
            - 참고로 배열도 객체와 같이 참조 변수를 통해 데이터가 저장된 공간에 접근하기 때문에 참조형 매개변수다.
## 참조형 반환타입
- 반환 타입이 참조형이라는 것의 의미는?
    - 메서드가 '객체의 주소'를 반환한다는 것
## 재귀 호출
- 메서드 내부에서 자기 자신을 다시 호출하는 것
- 대부분의 재귀 호출은 반복문으로 작성하는 것이 가능한데 반복문보다 재귀 호출의 수행 시간이 더 오래 걸린다
    - 왜? 메서드를 호출하는 건 매개 변수의 복사와 종료 후 복귀할 주소 저장 등이 추가로 필요하기 때문.
        - 그럼 왜 반복문 대신 재귀 호출을 쓸까?
            - 논릭적 간결함 때문, 따라서 재귀 호출에 드는 비용보다 간결함이 주는 이득이 충분히 클 때만 사용해야 한다. ex) 팩토리얼 n!
## 오버 로딩(overloading)
- 한 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것
- 오버로딩의 조건
    - 메서드 이름이 같아야 함
    - 매개 변수의 개수 또는 타입이 달라야 함
        - 반환 타입은 상관없다.
            - 왜? 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로.
- 예시
    - prinntln 메서드

- 장점
    - 메서드 이름만 보고 매개 변수가 다르더라도 같은 기능을 하겠다고 예측할 수 있음
    - 메서드 이름 절약
        - 하나의 메서드 이름으로 여러 개를 정의할 수 있기 때문에 메서드 이름 짓는 시간을 줄일 수 있다.
## 생성자
- 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드
    - ex) `클래스이름()`
- 조건
    - 생성자의 이름은 클래스의 이름과 같아야 한다.
    - 리턴값이 없다.
- 과정
    - 1. new 연산자에 의해 힙 메모리에 Goods 클래스의 인스턴스가 생성된다.
    - 2. 생성자 Goods() 가 호출된다.
    - 3. new 연산자의 결과로 생성된 Goods 인스턴스 주소가 참조 변수 goods에 저장된다.
```java
Goods goods = new Goods();
```
- this
    - 인스턴스 자신을 가르키는 **참조 변수**
    - 인스턴스의 주소가 저장되어 있음
- this(), this(매개변수)
    - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
## 변수의 초기화
- 멤버 변수(클래스 변수, 인스턴스 변수)와 배열의 초기화는 선택적
    - 기본값으로 자동 초기화(false, 0, null..)
- 지역 변수의 초기화는 필수적이다.
    - 초기화되지 않은 지역 변수의 사용은 컴파일 에러를 발생시킴
### 멤버 변수의 초기화 방법
- 명시적 초기화
    - 변수 선언과 동시에 초기화하는 것
- 생성자
- 초기화 블럭
    - 조건문, 반복문, 예외 처리 구문 등을 자유롭게 사용할 수 있기 때문에 초기화 작업이 복잡할 경우에 사용한다.
    - 종류
        - 인스턴스 초기화 블럭`{}`
            - 인스턴스를 만들 떄 마다 수행된다.
            - 인스턴스 변수 초기화는 주로 생성자를 이용하고, **인스턴스 초기화 블럭은 모든 생성자에서 공통적으로 수행돼야 하는** 코드를 넣는데 사용한다. (코드 중복 제거)
            - **생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.**
        - 클래스 초기화 블럭 `static {}`
			- 클래스가 메모리에 로딩될 때 처음 한번 수행
    - 실행 순서
        - 클래스 초기화 블럭 -> 인스턴스 초기화 블럭 -> 생성자

> Q. 책에서 저자가 생성자보다 인스턴스 초기화 블럭이 먼저 수행된다고 하는 걸 기억해두자고 한다. 실제로 사용한 경험이 있나요? 어떤 경우에 썼나요? 없다면 어떤 경우에 쓰는 게 좋을까요?