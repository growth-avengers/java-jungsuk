# 자바의 정석

# ch4-조건문과 반복문
> Q. switch 와 if 반복문 성능 차이에 대해서 설명해주세요. 그리고 어떤 기준으로 조건문을 선택해야할까요?

# ch5-배열
## 배열 복사하는 법
1. 기존 배열의 2배 정도 길이의 배열을 생성한다.
    - for문으로 기존 배열의 값을 하나 씩 접근해서 길이 2배 배열에 값을 저장한다.
    - 기존 배열의 참조 변수가 가리키는 값을 길이 2배 배열의 참조 변수 값으로 바꾼다.
- 2. System.Arraycopy() 이용
    - 요소 하나 하나 씩 접근해서 복사하는 게 아니라 지정된 범위의 값을 한번에 통째로 복사한다.
        - Q. 어떻게 가능할까?
            - 각 요소들이 연속적으로 저장되어 있다는 배열의 특성 때문에 가능하다.

> Q. 배열을 복사하는 방법에는 어떤 게 있나요? 그리고 효율적인 방법이 무엇이고 그 이유는?

# ch06-객체지향 프로그래밍1
## 클래스
- 객체를 생성하기 위한 툴
- 데이터와 함수의 결합
    - 참고
        - 변수: 하나의 데이터를 저장할 수 있는 공간
        - 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
        - 구조체: 관련된 여러 데이터를 종류에 관계 없이 하나의 집합으로 저장할 수 있는 공간
- 사용자 정의 타입
## 선언 위치에 따른 변수의 종류
- 클래스 변수(static 변수, 공유 변수)
    - 선언 위치: 클래스 영역
    - 생성 시기: 클래스가 메모리에 올라갈 때
    - 모든 인스턴스가 공통된 저장 공간(변수)을 공유한다.
    - 객체 생성 없이 `클래스이름.클래스변수`로 직접 사용 가능
- 인스턴스 변수
    - 선언 위치: 클래스 영역
    - 생성 시기: 인스턴스가 생성되었을 때
    - 인스턴스마다 서로 다른 값을 가짐
- 지역 변수
    - 선언 위치: 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블록 내부)
    - 생성 시기: 변수 선언문이 수행되었을 때
    - 메서드 내에서만 사용 가능
## 메서드
- 매개 변수의 유효성 검사 코드 필수
## JVM 메모리 구조
- 메서드 영역
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 .class 파일을 읽어서 클래스에 대한 정보를 메서드 영역에 저장한다.
- 힙
    - 인스턴스가 생성되는 공간
- 호출 스택(call stack or execution stack)
    - 메서드 작업에 필요한 메모리 공간 제공
    - 메서드가 작업을 마치면 메모리 공간은 반환되어 비워진다.
## 기본형 매개변수와 참조형 매개변수
- 기본형 매개변수
    - 변수의 값을 읽기만 할 수 있음
- 참조형 매개변수
    - 변수의 값을 읽고 변경할 수 있음
        - 어떻게? 값이 아니라 값이 저장된 주소가 매개변수로 전달됨.
            - 서로 다른 메서드 내에서 주소값을 갖고 있는 변수를 참조한다.
            - 참고로 배열도 객체와 같이 참조 변수를 통해 데이터가 저장된 공간에 접근하기 때문에 참조형 매개변수다.
## 참조형 반환타입
- 반환 타입이 참조형이라는 것의 의미는?
    - 메서드가 '객체의 주소'를 반환한다는 것
## 재귀 호출
- 메서드 내부에서 자기 자신을 다시 호출하는 것
- 대부분의 재귀 호출은 반복문으로 작성하는 것이 가능한데 반복문보다 재귀 호출의 수행 시간이 더 오래 걸린다
    - 왜? 메서드를 호출하는 건 매개 변수의 복사와 종료 후 복귀할 주소 저장 등이 추가로 필요하기 때문.
        - 그럼 왜 반복문 대신 재귀 호출을 쓸까?
            - 논릭적 간결함 때문, 따라서 재귀 호출에 드는 비용보다 간결함이 주는 이득이 충분히 클 때만 사용해야 한다. ex) 팩토리얼 n!
## 오버 로딩(overloading)
- 한 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것
- 오버로딩의 조건
    - 메서드 이름이 같아야 함
    - 매개 변수의 개수 또는 타입이 달라야 함
        - 반환 타입은 상관없다.
            - 왜? 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로.
- 예시
    - prinntln 메서드 