# 자바의 정석
# ch1-자바의 특징
## 1. 자바로 작성된 프로그램은 운영체제에 독립적이다.
- Write once, run anywhere
- 운영체제(OS)에 맞는 JVM(Java Virtual Machine)만 설치되어 있다면 문제 없이 동작한다.
    - 어떻게? JVM에 의해서. (JVM은 운영체제에 종속적이다.)
        - java 소스 파일이 OS 위에서 실행되기까지의 과정을 이해해야 한다.

## 2. 객체지향
- 객체지향의 특징인 캡상추다(캡슐화, 상속, 추상화, 다형성)가 잘 적용됨

## 3. Garbage Collection
- 가비지 컬렉터가 알아서 메모리 관리를 해준다.
- 자동으로 관리해주기 때문에 비효율적인 면도 있지만 개발자는 프로그래밍에만 집중할 수 있다는 장점이 있음
    - 어떻게 비효율적인가?
        - GC 실행 시점을 정확하게 알 수가 없음
        - GC 실행 시 애플리케이션을 중지시키는 stop the world가 발생하고 이는 오버헤드를 일으킴 -> 성능 저하


### JVM 동작 과정
- (자바 컴파일러에 의해 변환된) java btye code를 JVM에 의해 OS가 이해할 수 있는 기계어로 변환되고 OS에 전달한다.
  ![](https://i.imgur.com/TreAJuZ.png)
### JVM
![](https://i.imgur.com/23EJFb5.png)

#### JVM 단점
- 속도가 느리다.
    - 왜?
        - 일반 애플리케이션은 OS만 거치고 하드웨어를 전달하는데 자바 애플리케이션의 경우 JVM을 거치기 때문
        - 그리고 하드웨어에 맞게 완전히 컴파일된 상태가 아니라, 실행 시에 해석되기 때문
            - 바이트코드(컴파일된 자바코드)를 하드웨어의 기계어로 바로 변환해주는 **JIT컴파일러**와 향상된 최적화 기술이 적용되어서 속도의 격차를 많이 줄이긴 했다.

> Q. JIT 컴파일러의 동작 방식에 대해서 설명해주세요.
# ch2-변수
## 변수 정의
- 단 하나의 값을 저장할 수 있는 메모리 공간

## 변수를 선언하면?
- 메모리의 빈 공간에 변수 타입에 맞는 저장 공간을 확보한다.
- 변수 이름으로 해당 저장 공간을 접근해서 변수를 사용할 수 있게 된다.
```java 
int age = 10 // 변수 선언
```

## 자료형 (data type)
- data의 type에 따라 값이 저장될 공간의 크기와 저장 형식을 정의한 것

### 기본형과 참조형
#### 기본형 변수(primitive type)
- 계산을 위한 실제 값 저장
- 종류
    - 문자형
        - char
            - **내부적으로 정수(유니코드)로 저장**하기 때문에 정수형 또는 실수형과 연산할 수 있다.
    - 정수형
        - byte, short, int, long
    - 실수형
        - float, double
            - 정수형과 저장 방식이 달라서 같은 크기라도 훨씬 큰 값을 표현할 수 있다는 장점이 있다.
            - 그런데 오차가 발생할 수 있다는 단점이 있음.
                - **정밀도가 높을수록 오차 범위가 줄어든다.**
                    - float: 정밀도 7자리(10진수로 7자리의 수를 오차없이 저장할 수 있다는 뜻)
                    - double: 정밀도 15자리
    - 논리형
        - boolean
            - 다른 기본형과의 연산 불가능
#### 참조형 변수(reference type)
- 어떤 값이 저장되어 있는 주소를 값으로 갖는다.
- 자바는 C언어와 다르게 참조형 변수 간 연산을 할 수 없기 때문에 실제 연산에 사용되는 것은 모두 기본형 변수다.
- 8개의 기본형을 제외한 나머지 타입
- 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 것
    - 참조형 변수를 선언할 때는 변수의 타입으로 변수의 이름을 사용하기 때문에 클래스의 이름이 참조 변수의 타입이 된다.
- 참조 변수는 null 또는 객체의 주소를 값으로 갖는다.
    - null의 의미는?
        - 어떤 객체의 주소도 저장되어 있지 않음을 의미한다.
```java=
Date today = new Date (); 
```
- 객체를 생성하는 new의 결과는 생성된 객체의 주소다. 이 주소가 대입 연산자에 의해 참조 변수 today에 저장된다.
    - 참조 변수 today에 의해 생성된 객체를 쓸 수 있게 됨.

## 문자 인코딩
- 컴퓨터는 1과 0밖에 모름. 따라서 문자, 이미지, 동영상, 소리 등을 1과 0에 대응해서 표현해야 한다.
- 따라서 문자표가 필요하다.

### 문자표
- character set
- 숫자-문자 1:1 대응한 표
- 종류: 아스키코드, 유니코드, UTF-8 ...

### 아스키 코드
- character encoding
- 특히 문자를 1과 0으로 표현하기 위해서 문자표가 필요한데 대표적인 문자표가 아스키 코드표다.
- 7bit가 만들어 낼 수 있는 이진수 조합을 문자와 대응한 표(2^7, 128가지 표현)
- 한계: 영어만 표현 가능, 세계 각국의 문자 표현 불가능

### 유니코드
- universal character encoding
- 아스키코드 한계 극복
- 16bit를 활용한 유니코드가 나왔다. (2^16가지, 65536가지 문자 표현 가능)
- 모든 문자에 index를 지정시킨다.
    - 그 index를 code point, code unit이라 부름.
        - ex) 'A'라는 글자는 0x0041이라는 Index를 가진다.
- 한계: 영어는 1byte로 표현, 한글은 2byte로 표현... 가변적인 표현 방식
    - 이때 컴퓨터는 언제 1byte로 읽을지 알 수가 없기 때문에 1btye일때는 앞에 어떤 표시를 한다. 또 다른 표시가 있으면 2byte로 해석하는데 이렇게 해석하는 방식을 인코딩이라 한다.
        - 인코딩 방식이 여러가지가 있는데 UTF-8, UTF-16 등이 있는 것.

### UTF-8
- Unicode transformation format
- 유니코드라는 문자 집합을 UTF라는 문자열 인코딩 규칙으로 문자를 코드로 표현하는 것
    - 유니코드 문자를 인코딩 하는 방식
- 즉 UTF는 유니코드가 매핑해놓은 표를 보면서 사람의 언어 <-> 기계어로 변경해주는 역할을 한다. (인코딩)
- 8bit를 사용해서 1개의 index 표현
- 유니코드를 위한 가변 길이 인코딩 방식

### UTF-16
- 16bit를 사용해서 1개의 index 표현

>Q. long과 Long은 각각 어떤 기준으로 언제 써야 할까요?
# ch3-연산자
>Q. equals()와 == 의 차이는 무엇인가요?
# ch4-조건문과 반복문
> Q. switch 와 if 반복문 성능 차이에 대해서 설명해주세요. 그리고 어떤 기준으로 조건문을 선택해야할까요?

# ch5-배열
## 배열 복사하는 법
1. 기존 배열의 2배 정도 길이의 배열을 생성한다.
    - for문으로 기존 배열의 값을 하나 씩 접근해서 길이 2배 배열에 값을 저장한다.
    - 기존 배열의 참조 변수가 가리키는 값을 길이 2배 배열의 참조 변수 값으로 바꾼다.
- 2. System.Arraycopy() 이용
    - 요소 하나 하나 씩 접근해서 복사하는 게 아니라 지정된 범위의 값을 한번에 통째로 복사한다.
        - Q. 어떻게 가능할까?
            - 각 요소들이 연속적으로 저장되어 있다는 배열의 특성 때문에 가능하다.

> Q. 배열을 복사하는 방법에는 어떤 게 있나요? 그리고 효율적인 방법이 무엇이고 그 이유는?

# ch06-객체지향 프로그래밍1
## 클래스
- 객체를 생성하기 위한 툴
- 데이터와 함수의 결합
    - 참고
        - 변수: 하나의 데이터를 저장할 수 있는 공간
        - 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
        - 구조체: 관련된 여러 데이터를 종류에 관계 없이 하나의 집합으로 저장할 수 있는 공간
- 사용자 정의 타입
## 선언 위치에 따른 변수의 종류
- 클래스 변수(static 변수, 공유 변수)
    - 선언 위치: 클래스 영역
    - 생성 시기: 클래스가 메모리에 올라갈 때
    - 모든 인스턴스가 공통된 저장 공간(변수)을 공유한다.
    - 객체 생성 없이 `클래스이름.클래스변수`로 직접 사용 가능
- 인스턴스 변수
    - 선언 위치: 클래스 영역
    - 생성 시기: 인스턴스가 생성되었을 때
    - 인스턴스마다 서로 다른 값을 가짐
- 지역 변수
    - 선언 위치: 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블록 내부)
    - 생성 시기: 변수 선언문이 수행되었을 때
    - 메서드 내에서만 사용 가능
## 메서드
- 매개 변수의 유효성 검사 코드 필수
## JVM 메모리 구조
- 메서드 영역
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 .class 파일을 읽어서 클래스에 대한 정보를 메서드 영역에 저장한다.
- 힙
    - 인스턴스가 생성되는 공간
- 호출 스택(call stack or execution stack)
    - 메서드 작업에 필요한 메모리 공간 제공
    - 메서드가 작업을 마치면 메모리 공간은 반환되어 비워진다.
## 기본형 매개변수와 참조형 매개변수
- 기본형 매개변수
    - 변수의 값을 읽기만 할 수 있음
- 참조형 매개변수
    - 변수의 값을 읽고 변경할 수 있음
        - 어떻게? 값이 아니라 값이 저장된 주소가 매개변수로 전달됨.
            - 서로 다른 메서드 내에서 주소값을 갖고 있는 변수를 참조한다.
            - 참고로 배열도 객체와 같이 참조 변수를 통해 데이터가 저장된 공간에 접근하기 때문에 참조형 매개변수다.
## 참조형 반환타입
- 반환 타입이 참조형이라는 것의 의미는?
    - 메서드가 '객체의 주소'를 반환한다는 것
## 재귀 호출
- 메서드 내부에서 자기 자신을 다시 호출하는 것
- 대부분의 재귀 호출은 반복문으로 작성하는 것이 가능한데 반복문보다 재귀 호출의 수행 시간이 더 오래 걸린다
    - 왜? 메서드를 호출하는 건 매개 변수의 복사와 종료 후 복귀할 주소 저장 등이 추가로 필요하기 때문.
        - 그럼 왜 반복문 대신 재귀 호출을 쓸까?
            - 논릭적 간결함 때문, 따라서 재귀 호출에 드는 비용보다 간결함이 주는 이득이 충분히 클 때만 사용해야 한다. ex) 팩토리얼 n!
## 오버 로딩(overloading)
- 한 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것
- 오버로딩의 조건
    - 메서드 이름이 같아야 함
    - 매개 변수의 개수 또는 타입이 달라야 함
        - 반환 타입은 상관없다.
            - 왜? 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로.
- 예시
    - prinntln 메서드

- 장점
    - 메서드 이름만 보고 매개 변수가 다르더라도 같은 기능을 하겠다고 예측할 수 있음
    - 메서드 이름 절약
        - 하나의 메서드 이름으로 여러 개를 정의할 수 있기 때문에 메서드 이름 짓는 시간을 줄일 수 있다.
## 생성자
- 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드
    - ex) `클래스이름()`
- 조건
    - 생성자의 이름은 클래스의 이름과 같아야 한다.
    - 리턴값이 없다.
- 과정
    - 1. new 연산자에 의해 힙 메모리에 Goods 클래스의 인스턴스가 생성된다.
    - 2. 생성자 Goods() 가 호출된다.
    - 3. new 연산자의 결과로 생성된 Goods 인스턴스 주소가 참조 변수 goods에 저장된다.
```java
Goods goods = new Goods();
```
- this
    - 인스턴스 자신을 가르키는 **참조 변수**
    - 인스턴스의 주소가 저장되어 있음
- this(), this(매개변수)
    - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
## 변수의 초기화
- 멤버 변수(클래스 변수, 인스턴스 변수)와 배열의 초기화는 선택적
    - 기본값으로 자동 초기화(false, 0, null..)
- 지역 변수의 초기화는 필수적이다.
    - 초기화되지 않은 지역 변수의 사용은 컴파일 에러를 발생시킴
### 멤버 변수의 초기화 방법
- 명시적 초기화
    - 변수 선언과 동시에 초기화하는 것
- 생성자
- 초기화 블럭
    - 조건문, 반복문, 예외 처리 구문 등을 자유롭게 사용할 수 있기 때문에 초기화 작업이 복잡할 경우에 사용한다.
    - 종류
        - 인스턴스 초기화 블럭`{}`
            - 인스턴스를 만들 떄 마다 수행된다.
            - 인스턴스 변수 초기화는 주로 생성자를 이용하고, **인스턴스 초기화 블럭은 모든 생성자에서 공통적으로 수행돼야 하는** 코드를 넣는데 사용한다. (코드 중복 제거)
            - **생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.**
        - 클래스 초기화 블럭 `static {}`
			- 클래스가 메모리에 로딩될 때 처음 한번 수행
    - 실행 순서
        - 클래스 초기화 블럭 -> 인스턴스 초기화 블럭 -> 생성자

> Q. 책에서 저자가 생성자보다 인스턴스 초기화 블럭이 먼저 수행된다고 하는 걸 기억해두자고 한다. 실제로 사용한 경험이 있나요? 어떤 경우에 썼나요? 없다면 어떤 경우에 쓰는 게 좋을까요?

# ch07-객체지향 프로그래밍2
## 상속 이외에 클래스를 재사용하는 방법 -> 클래스 간 포함 관계를 맺어주는 것
- 한 클래스의 멤버 변수로 다른 클래스 타입의 참조 변수를 선언하는 것
- 장점
    - 코드가 간결해서 이해하기 쉽다.
    - 코드가 작게 나뉘어 작성되기 때문에 코드 관리도 수월하다.
```java
class Circle {
	int x;
	int y;
	int z;
}

Class Point {
	int x;
	int y;
}

-> 클래스 간 포함 관계를 맺어준다. 

class Circle {
	Point c = new Point();
	int z;
}

```
### 상속과 포함 관계의 차이 -> 아래 형태의 문장을 만들어본다.
- 차이점
    - 상속: ~은 ~이다. (is-a)
    - 포함: ~은 ~을 가지고 있다. (has-a)
- 클래스 간 가능한 한 많은 관계를 맺어서 **코드의 재사용성**을 높여야한다.

> Q. 단일 상속과 다중 상속의 장단점은?

## 오버라이딩
- 상속 관계에서 하위클래스에 맞게 상속받은 상위 클래스 메서드의 내용을 변경하는 것
- 조건
    - 이름, 매개변수, 반환타입이 같아야 함(->간단하게 말하면 선언부가 일치해야 함)
        - JDK 1.5부터 반환 타입이 하위 클래스의 타입이어도 된다.(->공변 반환 타입)
    - 예외
        - 상위 클래스보다 더 좁은 범위의 접근 제어자로 바꿀 수 없다.
            - 상위 클래스 (projected) -> 하위 클래스 (protected, public)만 가능
        - 상위 클래스보다 하위클래스에서 더 많은 예외를 선언할 수 없다.
            - 상위 클래스 (lOException, SQLException) -> 하위 클래스 (Exception) 불가
                - Exception 예외 클래스의 최고 조상이므로 더 많은 예외를 던질 수 있음. 단순히 선언된 예외 개수의 문제가 아니다.
        - 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없다.

## super
- 하위 클래스에서 상위 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.
## super()
- 상위 클래스의 생성자 호출하는데 사용된다.
- Object 클래스 제외 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 상위 클래스의 생성자를 호출해야한다. 없으면 컴파일러가 생성자 첫 줄에 임의로 `super();` 를 추가한다.
    - 생성자가 정의되어 있는 클래스에는 컴파일러가 기본 생성자를 자동적으로 추가하지 않는다.
## static
- 인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각각 다른 값을 갖는다.
- **static 멤버 변수**(클래스 변수)는 모든 인스턴스가 같은 값을 갖는다.
    - 하나의 변수를 모든 인스턴스가 공유하기 때문
    - 인스턴스를 생성하지 않고도 사용 가능하다.
    - 클래스가 메모리에 로드될 때 생성된다.
- satatic 메서드와 인스턴스 메서드의 근본적인 차이는 메서드 내에서 인스턴스 멤버를 사용하는 가 여부에 있다.
    - **static 메서드**의 경우
        - 인스턴스 멤버들을 직접 사용할 수 없다.
        - 인스턴스를 생성하지 않고도 호출이 가능하다.
- static 초기화 블럭은 클래스가 메모리에 로드될 때 단 한번만 수행되며 주로 클래스 변수(static 변수)를 초기화하는데 사용된다.

![](https://i.imgur.com/zykjeOF.png)
## final
>final: 마지막의, 변경될 수 없는
- 클래스
    - 변경,확장 불가 클래스
        - 다른 클래스의 상위 클래스가 될 수 없다. (->상속 불가)
    - ex) String, Math
- 메서드
    - 변경 불가 메서드(->오버라이딩 불가)
- 멤버 변수/지역 변수
    - 값 변경이 불가능한 상수가 된다.

## abstract
- 클래스
    - 클래스 내에 추상 메서드가 선언되어 있음을 의미
- 메서드
    - 선언부만 작성된 메서드, 구현X

## 생성자의 접근제어자
- 생성자의 접근제어자를 private 으로 하면 외부에서 생성자에 접근할 수 없다. 그런데 인스턴스 생성이 필요하다면 인스턴스를 생성해서 반환해주는 public satatic 메서드를 제공한다.
- 그리고 생성자의 접근자가 private 이면 하위 클래스에서 상위 클래스의 생성자를 호출 할 수 없어서 다른 클래스의 조상이 될 수 없기 때문에 클래스 선언부에 final 추가해서 상속할 수 없다는 것을 명시적으로 적는 것도 좋다.
- ex) Math 클래스
## 다형성
- 객체지향에서 다형성이란, 여러 가지 형태를 가질 수 있는 능력을 말한다.
- 구체적으로 말하면, 상위 클래스의 참조 변수로 하위 클래스의 인스턴스를 참조할 수 있도록 하는 것.
- 같은 타입의 인스턴스이더라도 참조 변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.
    - 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스 멤버의 개수보다 적거나 같아야 한다.
- 하위 클래스 타입의 참조 변수로 상위 클래스 타입의 인스턴스를 참조하는 것은 가능할까?
    - 불가능, 실제 인스턴스인 상위 클래스의 멤버 개수보다 하위 클래스의 참조 변수가 사용할 수 있는 멤버 변수가 더 많기 때문. (상속을 통해서 확장만 가능, 축소 불가능)

> Q. 인터페이스의 장점은 무엇이고 실제로 그 장점이 크게 와닿았던 적이 있나요?

# ch8-예외처리
- getMessage 메소드와 printStackTrace의 차이점은?
    - getMessage
        - 예외에 저장된 설명 String 반환
    - printStackTrace
        - 예외에 저장된 설명 String 반환
        - 예외의 클래스 이름
        - 메소드 호출 스택에 남아있는 모든 메소드 목록(실행이 완료되지 않은 메소드들의 목록)
> Q. Checked Exception과 Unchecked Exception 에 대해 설명해주세요. 그리고 어떤 걸 쓰는 게 좋을까요?
# ch9-java.lang패키지
- String 객체를 덧셈연산자‘+‘를 사용해서 문자열을 결합할 때 내부적으로 어떤 일이 발생할까? 그리고 이유는?
    - 매 연산시 마다 String 인스턴스가 생성돼 메모리 공간을 차지한다. 따라서 가능한 한 결합 횟수를 줄이는 게 좋고 연산 횟수가 많다면 String 클래스 대신, StringBuffer 나 StringBuilder 클래스를 사용하자.
    - 새로운 인스턴스를 생성하는 이유는 String 클래스는 Immutable한 성격을 가지기 때문.
- 문자열을 만드는 방법 2가지는? 그리고 차이는?
    - 문자열 리터럴을 지정해서 만든다.
        - 동일한 문자열인 경우, 주소를 참조해서 재사용한다.
        - 리터럴들이 JVM 내 Constant Pool에 저장된다.
    - String 클래스의 생성자를 사용해서 만든다.
        - 항상 새로운 String 인스턴스 생성
          ![](https://i.imgur.com/7RDszhS.png)
```java
String str1 = "abc";
String str2 = "abc";

String str3 = new String("abc");
String str4 = new String("abc");
```

## 래퍼 클래스
- 래퍼 클래스를 왜 쓸까?
    - 자바에서 8개의 기본형 타입을 객체로 다룰 필요가 있을 때
        - 비교, null 처리 등의 목적

> Q. 왜 32 bit JVM에서는 중복 해시 코드 이슈가 없었지만 64 bit JVM에서는 발생할까요?

## Random 클래스
> Q. Random 클래스에서 seed란 무엇인가요? 동일한 seed로 초기화된 인스턴스는 무조건 같은 난수를 생성할까요? 어떻게 보장할 수 있나요? 

# ch10-날짜와 시간 & 형식화
> Q. 사람이 알아보기 어려운 epoch time 은 실제로 언제 어떤 상황에서 쓰는 게 좋을까요?

# ch11-컬렉션 프레임워크
> Q. equals와 hashCode는 왜 같이 재정의하는 걸까요?

# ch12-generics, enumeration, annotation
> Q. Enum 클래스의 장점은 무엇인가요? 그리고 그 장점의 이유까지 설명해주세요.

# ch13-thread
> Q. volatile 키워드는 쓰레드들에 대한 변수 변경의 가시성을 보장한다고 하는데 구체적으로 어떤 의미인가요? 예시를 들어서 설명해주세요. 