# ch13. 쓰레드

- 프로세스 vs 쓰레드
	- 프로세스(process): 실행 중인 프로그램
	- 쓰레드(thread): 프로세스의 자원을 이용해 실제로 작업을 수행하는 것
- 멀티태스킹 vs 멀티쓰레딩
	- 멀티태스킹: 여러 개의 프로세스를 동시에 실행하는 것
		- 대부분의 OS는 멀티태스킹을 지원
	- 멀티쓰레딩: 하나의 프로세스 내에서 여러 개의 쓰레드가 동시에 작업을 수행하는 것
		- CPU의 코어(core) 하나에 하나의 작업만 수행할 수 있으므로, 실제로는 코어의 개수 이상의 작업을 동시에 할 수 없음
		- 코어가 아주 짧은 시간 동안 여러 작업을 번갈아 가며 수행함으로써 동시에 수행되는 것 처럼 보임
- 멀티쓰레딩의 장단점
	- CPU 사용률 향상
	- 사용자에 대한 응답성 향상
	- 동기화 문제
	- 교착상태(deadlock)
- 쓰레드 구현 방법
	- Thread 클래스 상속
	- Runnable 인터페이스 구현
- run() vs start()
	- run(): 호출된 call stack에서 작업을 실행. 반복 호출 가능
	- start(): 새로운 call stack을 생성한 다음 거기에서 run() 호출. 반복 호출시 `IllegalThreadStateException`
- 데몬 쓰레드
	- 데몬 쓰레드가 아닌 일반 쓰레드를 돕는 보조적인 역할을 하는 쓰레드
	- GC, 자동 저장, 화면 자동 갱신 등
	- 무한루프와 조건문을 이용해 실행 후 대기하고 있다가 조건이 만족되면 작업을 수행하고 일반 쓰레드가 종료되면 자동 종료
- 쓰레드의 상태
	- NEW: 쓰레드가 생성되었지만 아직 start() 호출되지 않은 상태
	- RUNNABLE: 실행 중 또는 실행 가능 상태
	- BLOCKED: 동기화 블럭에 의해 일시정지된 상태(lock이 풀릴때까지 대기)
	- WAITING: 쓰레드의 작업이 종료되지는 않았지만 실행불가능한 일시정지 상태
	- TIMED_WAITING: WAITING 상태와 동일하지만 일시정지시간이 지정된 경우
	- TERMINATED: 쓰레드의 작업이 종료된 상태
- 쓰레드의 동기화
	- `synchronized` 블럭
		- 메서드 전체
		- 특정 영역
		- `wait()`, `notify()`, `notifyAll()`
			- 동기화된 영역의 코드를 수행 중 더 이상 작업을 진행할 상황이 아니면 `wait()`를 호출해 락을 반납하고 기다린다. 
			- 작업을 진행할 수 있는 상황이 되면 `notify()`를 호출해 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.
			- 특징
				- Object에 정의되어 있음
				- 동기화 블럭내에서만 사용 가능
				- 효율적인 동기화
	- `Lock` 클래스(`java.util.concurrent.locks`)
		- `ReentrantLock`: 재진입 가능한 lock. 가장 일반적인 배타 lock
		- `ReentrantReadWriteLock`: 읽기에는 공유. 쓰기에는 배타적인 lock
			- 읽기 lock이 걸린 상태에서 쓰기 lock을 걸 수 없음
		- `StampedLock`: `ReentrantReadWriteLock`에 낙관적인 읽기 lock 기능 추가. Lock 인터페이스를 구현하지 않음
			- 낙관적 읽기를 지원해 읽기 thread의 기아상태(starvation) 회피
			- lock을 upgrade(반대 모드로 lock을 변경)할 수 있음
	- `volatile`: 코어가 변수의 값을 읽을 때 캐시가 아닌 메모리에서 읽어와서 캐시와 메모리간의 값의 불일치 해결
		- JVM은 데이터를 4byte 단위로 처리해서 long, double 타입은 하나의 명령어로 값을 읽거나 쓸 수 없다.
		- long, double 타입의 변수에 `volatile`을 붙이면 해당 변수를 원자화(작업을 더 이상 나눌 수 없음)된다.
	- fork & join 프레임워크
